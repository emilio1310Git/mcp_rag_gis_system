#!/usr/bin/env python3
"""
Script principal para ejecutar todos los servidores MCP del sistema RAG GIS v2.0

Este script gestiona de forma centralizada:
- Servidor MCP RAG: Procesamiento de documentos y consultas inteligentes
- Servidor MCP Maps: Mapas b√°sicos y b√∫squeda de equipamientos  
- Servidor MCP GIS: An√°lisis geoespacial avanzado con PostgreSQL

Funcionalidades:
- Inicio secuencial y controlado de servidores
- Monitorizaci√≥n continua del estado
- Cierre limpio y seguro de todos los procesos
- Manejo robusto de errores y se√±ales del sistema
"""

import asyncio
import subprocess
import sys
import signal
import time
import logging
from pathlib import Path
from typing import Dict, Optional, List
from dataclasses import dataclass

# Configuraci√≥n de logging con formato estructurado
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - [%(levelname)s] - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

@dataclass
class ServerConfig:
    """
    Configuraci√≥n de un servidor MCP individual
    
    Attributes:
        name: Nombre descriptivo del servidor
        module_path: Ruta del m√≥dulo Python (formato src.mcp_servers.server_name)
        description: Descripci√≥n de las funcionalidades del servidor
        critical: Si es True, el fallo de este servidor detiene todo el sistema
    """
    name: str
    module_path: str
    description: str
    critical: bool = True

class ServerManager:
    """
    Gestor centralizado de servidores MCP
    
    Responsabilidades:
    - Iniciar y detener servidores de forma controlada
    - Monitorizar el estado de los procesos
    - Manejar se√±ales del sistema (Ctrl+C, SIGTERM)
    - Proporcionar logging detallado de operaciones
    """
    
    def __init__(self) -> None:
        """
        Inicializar el gestor de servidores
        
        Inicializa las estructuras de datos y configura los servidores disponibles
        """
        # Diccionario que mapea nombre_servidor -> proceso subprocess
        self.processes: Dict[str, subprocess.Popen] = {}
        
        # Flag que controla el bucle de monitorizaci√≥n
        self.running: bool = False
        
        # Directorio ra√≠z del proyecto
        self.project_root = Path(__file__).parent.parent
        
        # Configuraci√≥n de los servidores MCP disponibles
        self.server_configs: List[ServerConfig] = [
            ServerConfig(
                name="RAG",
                module_path="src.mcp_servers.rag_server",
                description="Procesamiento de documentos y consultas RAG con LangChain + Ollama",
                critical=True
            ),
            ServerConfig(
                name="Maps", 
                module_path="src.mcp_servers.maps_server",
                description="Mapas interactivos y b√∫squeda de equipamientos via OpenStreetMap",
                critical=False
            ),
            ServerConfig(
                name="GIS",
                module_path="src.mcp_servers.gis_server", 
                description="An√°lisis geoespacial avanzado con PostgreSQL/PostGIS",
                critical=False
            )
        ]
        
        logger.info("üèóÔ∏è ServerManager inicializado")
        
    def _validate_server_modules(self) -> List[ServerConfig]:
        """
        Validar que todos los m√≥dulos de servidores existen
        
        Returns:
            Lista de configuraciones de servidores v√°lidos
            
        Raises:
            FileNotFoundError: Si alg√∫n m√≥dulo cr√≠tico no existe
        """
        valid_servers: List[ServerConfig] = []
        missing_critical: List[str] = []
        
        for config in self.server_configs:
            # Convertir ruta de m√≥dulo a ruta de archivo
            module_file_path = self.project_root / config.module_path.replace(".", "/") + ".py"
            
            if module_file_path.exists():
                valid_servers.append(config)
                logger.info(f"‚úÖ M√≥dulo encontrado: {config.module_path}")
            else:
                logger.warning(f"‚ö†Ô∏è M√≥dulo no encontrado: {module_file_path}")
                if config.critical:
                    missing_critical.append(config.name)
        
        # Si faltan servidores cr√≠ticos, detener la ejecuci√≥n
        if missing_critical:
            error_msg = f"Servidores cr√≠ticos no encontrados: {missing_critical}"
            logger.error(f"‚ùå {error_msg}")
            raise FileNotFoundError(error_msg)
            
        return valid_servers
    
    def start_server(self, config: ServerConfig) -> bool:
        """
        Iniciar un servidor MCP individual
        
        Args:
            config: Configuraci√≥n del servidor a iniciar
            
        Returns:
            True si el servidor se inici√≥ correctamente, False en caso contrario
        """
        try:
            logger.info(f"üöÄ Iniciando servidor {config.name}...")
            logger.debug(f"   M√≥dulo: {config.module_path}")
            logger.debug(f"   Descripci√≥n: {config.description}")
            
            # Crear proceso subprocess para el servidor usando -m
            process = subprocess.Popen(
                [sys.executable, "-m", config.module_path],
                stdout=subprocess.PIPE,  # Capturar stdout para logging
                stderr=subprocess.PIPE,  # Capturar stderr para debugging
                text=True,              # Usar strings en lugar de bytes
                bufsize=1,              # Buffering l√≠nea por l√≠nea
                universal_newlines=True,
                cwd=str(self.project_root)  # Ejecutar desde ra√≠z del proyecto
            )
            
            # Verificar que el proceso se inici√≥ correctamente
            # Esperar un momento para detectar errores inmediatos
            time.sleep(0.5)
            
            if process.poll() is None:  # None significa que el proceso sigue ejecut√°ndose
                self.processes[config.name] = process
                logger.info(f"‚úÖ Servidor {config.name} iniciado correctamente (PID: {process.pid})")
                return True
            else:
                # El proceso termin√≥ inmediatamente, probablemente un error
                stderr_output = process.stderr.read() if process.stderr else "No disponible"
                logger.error(f"‚ùå Servidor {config.name} fall√≥ al iniciar")
                logger.error(f"   Error: {stderr_output}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error iniciando servidor {config.name}: {e}")
            return False
    
    def stop_all_servers(self) -> None:
        """
        Detener todos los servidores de forma segura
        
        Implementa un cierre en dos fases:
        1. Terminaci√≥n suave (SIGTERM) con timeout
        2. Terminaci√≥n forzada (SIGKILL) si es necesario
        """
        if not self.processes:
            logger.info("‚ÑπÔ∏è No hay servidores activos para detener")
            return
            
        logger.info("üõë Iniciando cierre de servidores...")
        
        # Fase 1: Terminaci√≥n suave
        for name, process in self.processes.items():
            try:
                logger.info(f"üîÑ Deteniendo servidor {name} (PID: {process.pid})...")
                process.terminate()  # Enviar SIGTERM
                
            except Exception as e:
                logger.error(f"‚ö†Ô∏è Error enviando SIGTERM a {name}: {e}")
        
        # Fase 2: Esperar terminaci√≥n con timeout y forzar si es necesario
        timeout_seconds = 5
        for name, process in list(self.processes.items()):
            try:
                # Esperar que el proceso termine voluntariamente
                process.wait(timeout=timeout_seconds)
                logger.info(f"‚úÖ Servidor {name} detenido correctamente")
                
            except subprocess.TimeoutExpired:
                # El proceso no termin√≥ en el tiempo esperado, forzar cierre
                logger.warning(f"‚ö†Ô∏è Servidor {name} no respondi√≥, forzando cierre...")
                try:
                    process.kill()  # Enviar SIGKILL
                    process.wait(timeout=2)
                    logger.info(f"üî® Servidor {name} terminado forzadamente")
                except Exception as e:
                    logger.error(f"‚ùå Error forzando cierre de {name}: {e}")
                    
            except Exception as e:
                logger.error(f"‚ùå Error deteniendo servidor {name}: {e}")
        
        # Limpiar el diccionario de procesos
        self.processes.clear()
        self.running = False
        logger.info("‚úÖ Todos los servidores han sido detenidos")
    
    def signal_handler(self, signum: int, frame) -> None:
        """
        Manejador de se√±ales del sistema (Ctrl+C, SIGTERM, etc.)
        
        Args:
            signum: N√∫mero de la se√±al recibida
            frame: Frame de ejecuci√≥n actual (no usado)
        """
        signal_names = {
            signal.SIGINT: "SIGINT (Ctrl+C)",
            signal.SIGTERM: "SIGTERM",
            signal.SIGQUIT: "SIGQUIT"
        }
        
        signal_name = signal_names.get(signum, f"Se√±al {signum}")
        logger.info(f"üì° Se√±al recibida: {signal_name}")
        
        # Detener todos los servidores y salir
        self.stop_all_servers()
        logger.info("üëã Sistema detenido por se√±al del usuario")
        sys.exit(0)
    
    async def monitor_servers(self) -> None:
        """
        Monitorizar continuamente el estado de los servidores
        
        Funcionalidades:
        - Detecta servidores que han terminado inesperadamente
        - Registra logs de estado cada cierto tiempo
        - Permite restart autom√°tico (opcional, no implementado)
        """
        logger.info("üîç Iniciando monitorizaci√≥n de servidores...")
        
        monitor_interval = 5  # segundos
        health_check_interval = 30  # segundos  
        last_health_check = time.time()
        
        while self.running:
            current_time = time.time()
            servers_alive = 0
            servers_dead = []
            
            # Verificar estado de cada servidor
            for name, process in list(self.processes.items()):
                return_code = process.poll()
                
                if return_code is None:
                    # Proceso sigue ejecut√°ndose
                    servers_alive += 1
                else:
                    # Proceso ha terminado
                    servers_dead.append(name)
                    logger.error(f"üíÄ Servidor {name} ha terminado inesperadamente (c√≥digo: {return_code})")
                    
                    # Leer stderr para diagnosticar el problema
                    try:
                        if process.stderr:
                            stderr_content = process.stderr.read()
                            if stderr_content:
                                logger.error(f"   Error de {name}: {stderr_content}")
                    except Exception:
                        pass  # No es cr√≠tico si no podemos leer stderr
                    
                    # Remover del diccionario de procesos activos
                    del self.processes[name]
            
            # Log de estado peri√≥dico
            if current_time - last_health_check >= health_check_interval:
                logger.info(f"üìä Estado del sistema: {servers_alive} servidores activos")
                last_health_check = current_time
            
            # Si todos los servidores han muerto, detener monitorizaci√≥n
            if not self.processes:
                logger.error("üí• Todos los servidores han terminado, deteniendo sistema")
                self.running = False
                break
            
            # Esperar antes de la siguiente verificaci√≥n
            await asyncio.sleep(monitor_interval)
        
        logger.info("üîç Monitorizaci√≥n de servidores finalizada")
    
    def display_startup_info(self) -> None:
        """
        Mostrar informaci√≥n de estado tras el inicio del sistema
        """
        print("\n" + "="*70)
        print("üéØ SISTEMA MCP RAG GIS v2.0 - ESTADO DE SERVIDORES")
        print("="*70)
        
        if self.processes:
            print(f"üìã Servidores activos ({len(self.processes)}):")
            for name, process in self.processes.items():
                config = next((c for c in self.server_configs if c.name == name), None)
                print(f"  ‚úÖ {name:<8} (PID: {process.pid:<6}) - {config.description if config else 'N/A'}")
        else:
            print("‚ùå No hay servidores activos")
            return
        
        print("\nüîó Endpoints disponibles:")
        print("  ‚Ä¢ Servidores MCP: Listos para conexi√≥n con Claude/IA")
        print("  ‚Ä¢ API REST: http://localhost:8000 (si est√° configurada)")
        print("  ‚Ä¢ Documentaci√≥n: http://localhost:8000/docs")
        
        print(f"\nüìù Logs del sistema:")
        print(f"  ‚Ä¢ Nivel de log: {logging.getLogger().level}")
        print(f"  ‚Ä¢ Monitorizaci√≥n: Cada 5 segundos")
        
        print(f"\n‚å®Ô∏è  Controles:")
        print(f"  ‚Ä¢ Ctrl+C: Detener todos los servidores")
        print(f"  ‚Ä¢ Estado: Visible en logs cada 30 segundos")
        print("="*70 + "\n")
    
    def run(self) -> None:
        """
        Ejecutar el sistema completo de servidores MCP
        
        Flujo principal:
        1. Validar m√≥dulos de servidores
        2. Configurar manejadores de se√±ales  
        3. Iniciar servidores secuencialmente
        4. Mostrar informaci√≥n de estado
        5. Iniciar monitorizaci√≥n continua
        """
        logger.info("üöÄ Iniciando Sistema MCP RAG GIS v2.0")
        
        try:
            # Paso 1: Validar que todos los m√≥dulos existen
            valid_servers = self._validate_server_modules()
            logger.info(f"‚úÖ Validaci√≥n completada: {len(valid_servers)} servidores disponibles")
            
            # Paso 2: Configurar manejadores de se√±ales para cierre limpio
            signal.signal(signal.SIGINT, self.signal_handler)   # Ctrl+C
            signal.signal(signal.SIGTERM, self.signal_handler)  # Terminaci√≥n del proceso
            logger.info("üõ°Ô∏è Manejadores de se√±ales configurados")
            
            # Paso 3: Iniciar servidores secuencialmente
            successful_starts = 0
            for config in valid_servers:
                success = self.start_server(config)
                if success:
                    successful_starts += 1
                    # Pausa entre inicios para evitar conflictos de recursos
                    time.sleep(2)
                else:
                    if config.critical:
                        logger.error(f"‚ùå Servidor cr√≠tico {config.name} fall√≥, deteniendo sistema")
                        self.stop_all_servers()
                        return
                    else:
                        logger.warning(f"‚ö†Ô∏è Servidor no cr√≠tico {config.name} fall√≥, continuando...")
            
            # Verificar que al menos un servidor se inici√≥
            if successful_starts == 0:
                logger.error("‚ùå No se pudo iniciar ning√∫n servidor")
                return
            
            # Paso 4: Sistema iniciado correctamente
            self.running = True
            logger.info(f"üéâ Sistema iniciado: {successful_starts}/{len(valid_servers)} servidores activos")
            
            # Mostrar informaci√≥n de estado
            self.display_startup_info()
            
            # Paso 5: Iniciar monitorizaci√≥n continua (bloqueante)
            try:
                asyncio.run(self.monitor_servers())
            except KeyboardInterrupt:
                # Esta excepci√≥n normalmente la maneja signal_handler, 
                # pero por seguridad la capturamos aqu√≠ tambi√©n
                logger.info("‚å®Ô∏è Interrupci√≥n de teclado detectada")
                self.signal_handler(signal.SIGINT, None)
                
        except Exception as e:
            logger.error(f"üí• Error fatal en el sistema: {e}")
            self.stop_all_servers()
            raise
        
        finally:
            # Asegurar limpieza final
            if self.processes:
                logger.info("üßπ Limpieza final del sistema...")
                self.stop_all_servers()

def main() -> None:
    """
    Punto de entrada principal del script
    
    Crea una instancia del ServerManager y ejecuta el sistema
    """
    try:
        manager = ServerManager()
        manager.run()
    except KeyboardInterrupt:
        logger.info("üëã Sistema interrumpido por el usuario")
        sys.exit(0)
    except Exception as e:
        logger.error(f"üí• Error fatal no manejado: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()